\documentclass[a4paper]{article}

\usepackage{amssymb,mathrsfs,amsmath,amscd,amsthm}
\usepackage[mathcal]{euscript}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage{graphics}

%%%%%%% makra do notacji

\renewcommand{\phi}{\varphi}
\newcommand{\eps}{\varepsilon}
\newcommand{\nr}[1]{\smallcaps{NR#1}}

\newcommand{\bin}{\textrm{bin}}

\newcommand{\rev}{{\mathsf R}}
\newcommand{\N}{\mathbb N}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\setof}[2]{\{#1\mid #2\}}
\newcommand{\from}{\colon}

\renewcommand{\subset}{\subseteq}
\newcommand{\aut}[1]{\mathcal {#1}}
\newcommand{\reg}[1]{\mathcal {#1}}
\newcommand{\gram}[1]{\mathcal {#1}}
\newcommand{\lang}{L}

\newcommand{\tran}[1]{\xrightarrow{#1}}

\newcommand{\produce}{\rightarrow}
\newcommand{\sep}{\mathop{\big|}}


\newcommand{\prefix}{\mathit{prefix}}
\newcommand{\infix}{\mathit{infix}}
\newcommand{\suffix}{\mathit{suffix}}
\newcommand{\pleft}{\mathit{left}}
\newcommand{\pright}{\mathit{right}}

\newcommand{\tranp}[3]{\xrightarrow{\textbf{pop}(#1), #2 ,\textbf{push}(#3)}}
\newcommand{\trant}[5]{#1,\textbf{read}(#2):\textbf{write}(#4),\textbf{state}(#3),\textbf{move}(#5)}



\begin{document}

\title{SEMWER zadanie 2, am418402}

\maketitle

\section*{Dziedziny semantyczne}

\subsection*{Stan}

Ponieważ wszystkie zmienne są globalne, oraz traktujemy je jako zadeklarowane i z nadaną wartością, to nie potrzebujemy środowiska zmiennych, a stan ma po prostu postać

$$
\text{State} = \text{Var} \longrightarrow \text{Int}
$$

i skoro wszystkie zmienne mają wartość, nie jest to funkcja częściowa. Powstaje tutaj pytanie, jaką wartość mają zmienne, którym nie nadano jeszcze w programie żadnej wartości - wszak można się do nich odwołać. To jednak nie zależy od denotacji instrukcji i wyrażeń, więc nie jest częścią zadania. Można to ustalić np. podając stan ''początkowy'' w denotacji programów.

\subsection*{Typy kontynuacji}

Skoro wynikiem działania instrukcji ma być stan końcowy, to kontynuacje mają postać

$$
\text{Cont} = \text{State} \rightharpoonup \text{State}
$$

Ale dla rozróżnienia wprowadzę typ $\text{Ans}=\text{State}$ i będę pisał

$$
\text{Cont} = \text{State} \rightharpoonup \text{Ans}
$$

Dalej, dla kontynuacji wyrażeń arytmetycznych:

$$
\text{Cont}_E = \text{Int} \longrightarrow \text{State} \rightharpoonup\text{Ans}
$$

Tutaj istotne jest, że wyrażenia mogą zmieniać stan, więc nie może być $\text{Cont}_E = \text{Num} \rightharpoonup \text{Ans}$. Dla wyrażeń boolowskich:

$$
\text{Cont}_B = \text{Bool} \longrightarrow \text{State} \rightharpoonup \text{Ans}
$$

a dla deklaracji:

$$
\text{Cont}_D = \text{FEnv} \rightharpoonup \text{Ans}
$$

Gdzie $\text{FEnv}$ to opisane niżej środowisko funkcji. Tym razem jest istotne, że deklaracje nie zmieniają stanu.

\subsection*{Środowisko funkcji}

Środowisko funkcji ma postać

$$
\text{FEnv} = \text{FName} \rightharpoonup \text{Fun}
$$

Gdzie $\text{FName}$ to nazwy funkcji, natomiast funkcje reprezentuje typ $\text{Fun}$:

$$
\text{Fun} = (\text{Cont} \longrightarrow \text{Cont}_E \longrightarrow \text{State} \rightharpoonup \text{Ans}) \times \text{Expr}
$$

Jak warto zauważyć, w pierwszej części produktu podajemy jako argumenty dwie różne kontynuacje. Ma to na celu umożliwienie zarówno wykonania całości ciała funkcji, jak i wyjście z niej wcześniej za pomocą instrukcji $\texttt{return}$. Ta pierwsza część intuicyjnie jest odpowiedzialna za wykonanie ciała funkcji. Natomiast druga część produktu to wyrażenie odpowiedzialne za domyślny wynik działania funkcji. W środowisku należy pamiętać całe to wyrażenie, gdyż będzie ono wyliczane przed każdym wywołaniem funkcji.


\section*{Typy funkcji semantycznych}

Dla instrukcji:
$$
\mathcal{I}[\![]\!]: \text{Instr} \longrightarrow \text{FEnv} \longrightarrow \text{Cont} \longrightarrow \text{Cont}_E \longrightarrow \text{State} \rightharpoonup \text{Ans}
$$

Ponownie, i z analogicznych powodów, mamy tu dwie różne kontynuacje. Dla wyrażeń arytmetycznych jest:
$$
\mathcal{E}[\![]\!]: \text{Expr} \longrightarrow \text{FEnv} \longrightarrow \text{Cont}_E \longrightarrow \text{State} \rightharpoonup \text{Ans}
$$

i tym razem oczywiście nie potrzebujemy dwóch różnych kontynuacji. Dla wyrażeń boolowskich analogicznie:
$$
\mathcal{B}[\![]\!]: \text{BExpr} \longrightarrow \text{FEnv} \longrightarrow \text{Cont}_B \longrightarrow \text{State} \rightharpoonup \text{Ans}
$$

Dla deklaracji:
$$
\mathcal{D}[\![]\!]: \text{FDecl} \longrightarrow \text{FEnv} \longrightarrow \text{Cont}_D \longrightarrow \text{State} \rightharpoonup \text{Ans}
$$


\section*{Denotacje}

\subsection*{Denotacje wyrażeń}

$$
\mathcal{E}[\![n]\!] \rho_F \; \kappa_E \; s = \kappa_E(\mathcal{N}[\![n]\!]) \; s
$$

$$
\mathcal{E}[\![ x ]\!] \rho_F \; \kappa_E \; s = \kappa_E(s \; x) \; s
$$

$$
\mathcal{E}[\![e_1 + e_2]\!] \rho_F \; \kappa_E \; s = \mathcal{E}[\![e_1]\!] \rho_F (\lambda n_1.
\mathcal{E}[\![e_2]\!] \rho_F (\lambda n_2.
\kappa_E (n_1+n_2))) s
$$

Denotacje dla odejmowania i mnożenia są analogiczne.

$$
\mathcal{E}[\![ f() ]\!] \rho_F \; \kappa_E \; s = \mathcal{E}[\![ e_d ]\!] \rho_F (\lambda n. \; \beta \; \kappa_E(n) \; \kappa_E) s
$$
gdzie
$$
\rho_F(f) = (\beta, e_d)
$$

Innymi słowy, wyciągamy ze środowiska funkcji krotkę oznaczającą ciało funkcji i jej wyrażenie domyślne, i przekazujemy kontrolę wyrażeniu domyślnemu, mówiąc, że tym, co się stanie z jego wynikiem $n$, będzie nowo skonstruowana kontynuacja wyrażenia arytmetycznego zależna od $n$. Ta kontynuacja z kolei jest - nieformalnie mówiąc - wykonaniem ciała funkcji, biorąc jako kontynuację domyślną $\kappa_E(n)$, a jako kontynuację dla instrukcji $\texttt{return}$ - $\kappa_E$.


$$
\mathcal{B}[\![ \text{true} ]\!] \rho_F \; \kappa_B \; s = \kappa_B \; \text{tt} \; s
$$

analogicznie dla fałszu.

$$
\mathcal{B}[\![ \text{not} \; b]\!] \rho_F \; \kappa_B \; s = \mathcal{B}[\![b]\!] \; \rho_F \; (\lambda d. \; \kappa_B \; (\lnot d) ) s
$$

$$
\mathcal{B}[\![b_1 \land b_2]\!] \rho_F \; \kappa_B \; s = \mathcal{B}[\![b_1 ]\!] \rho_F \; (\lambda d_1. \; \mathcal{B}[\![b_2]\!] \; \rho_F \; (\lambda d_2. \kappa_B(d_1 \land d_2))) s
$$

$$
\mathcal{B}[\![ e_1 < e_2 ]\!] \rho_F \; \kappa_B \; s = \mathcal{E}[\![e_1]\!] \rho_F (\lambda n_1.
\mathcal{E}[\![e_2]\!] \rho_F (\lambda n_2.
\kappa_B (n_1 < n_2))) s
$$

Dla $e_1 = e_2$ analogicznie.

\subsection*{Denotacje instrukcji}

$$
\mathcal{I}[\![ x := e ]\!] \; \rho_F \; \kappa \; \kappa_E \; s = \mathcal{I}[\![ e ]\!] \; \rho_F \; (\lambda n. \lambda s'. \; \kappa \; s'[x \mapsto n]) \; \kappa_E \; s
$$

$$
\mathcal{I}[\![ I_1; I_2 ]\!] \; \rho_F \; \kappa \; \kappa_E \; s = \mathcal{I}[\![ I_1 ]\!] \; \rho_F \; (
\mathcal{I}[\![ I_2 ]\!] \; \rho_F \; \kappa \; \kappa_E \;
) \; \kappa_E \; s
$$

$$
\mathcal{I}[\![ \text{if} \; b \; \text{then} \; I_1 \; \text{else} \; I_2 ]\!] \; \rho_F \; \kappa \; \kappa_E \; s = \mathcal{B}[\![ b ]\!] \; \rho_F \; (\lambda d. ifte (d, \;
\mathcal{I}[\![ I_1 ]\!] \; \rho_F \; \kappa \; \kappa_E
, \; 
\mathcal{I}[\![ I_2 ]\!] \; \rho_F \; \kappa \; \kappa_E
)) \; \; s
$$

''Robocza'', niestałopunktowa denotacja instrukcji $\texttt{while}$ wyglądałaby tak:

$$
\mathcal{I}[\![ \text{while} \; b \; \text{do} \; I  ]\!] \; \rho_F \; \kappa \; \kappa_E \; s = \mathcal{B}[\![ b ]\!] \; \rho_F \; (\lambda d. ifte (d, \;
\mathcal{I}[\![ \text{while} \; b \; \text{do} \; I  ]\!] \; \rho_F \; \kappa \; \kappa_E
, \; 
\kappa
)) \; s
$$


denotacja bloku

denotacja returna

\subsection*{Denotacje deklaracji}

widoczność funkcji jest statyczna - tzn jeśli mamy funkcję f która wywołuje funkcję g, i w momencie deklaracji f jest widoczna g, a potem w jakimś bloku mamy przesłonioną definicję g i wywołamy f, to f skorzysta z tego g, które zobaczyła w momencie deklaracji, a nie wywołania. innymi słowy funkcje pamiętają środowisko funkcji z momentu deklaracji (wywołanie nie przyjmuje środowiska funkcji jako argumentu - no w każdym razie, na slajdach było jak zrobić widoczność statyczną)

funkcje są rekurencyjne, więc definicja deklaracji funkcji musi być stałopunktowa.

denotacja deklaracji funkcji

denotacja złożenia deklaracji funkcji też

\end{document}















